# postgresql.conf - Optimized for home server running in Docker/LXC

# =============================================================================
# CONNECTION AND AUTHENTICATION
# =============================================================================

# Allow connections from any IP address - essential for Docker containers
# since applications connect from different network interfaces
listen_addresses = '*'

# Standard PostgreSQL port - explicitly set for clarity
port = 5432

# =============================================================================
# RESOURCE USAGE (MEMORY)
# =============================================================================

# Memory for caching database pages in shared memory
# 256MB is conservative for home servers (typically 25% of RAM for dedicated
# servers, but lower for shared systems to avoid overwhelming the host)
shared_buffers = 256MB

# Tells the query planner how much memory is available for caching
# (OS page cache + PostgreSQL shared_buffers combined)
# Helps optimizer make better decisions about index vs sequential scans
effective_cache_size = 1GB

# Memory allocated per operation (sorts, hash joins, etc.)
# 4MB prevents excessive memory usage when multiple operations run simultaneously
# Total memory usage = work_mem Ã— number of concurrent operations
work_mem = 4MB

# Memory for maintenance operations (VACUUM, CREATE INDEX, ALTER TABLE)
# Higher than work_mem since these operations run less frequently
# and benefit from more memory
maintenance_work_mem = 64MB

# =============================================================================
# CONNECTION HANDLING
# =============================================================================

# Maximum number of concurrent connections
# 100 is reasonable for home use - each connection uses memory
# Balances availability with resource usage
max_connections = 100

# Reserve connections for superuser access even when max_connections is reached
# Ensures admin access for troubleshooting when database is busy
superuser_reserved_connections = 3

# =============================================================================
# WRITE-AHEAD LOGGING (WAL)
# =============================================================================

# WAL level - 'replica' enables full logging for potential replication/backup
# Provides good data safety and allows for point-in-time recovery
wal_level = replica

# Maximum WAL size before triggering automatic checkpoint
# Larger values reduce checkpoint frequency but use more disk space
# 1GB is good balance for home servers
max_wal_size = 1GB

# Minimum WAL size to maintain - prevents constant WAL file creation/deletion
# Balances performance with disk space usage
min_wal_size = 80MB

# =============================================================================
# QUERY TUNING
# =============================================================================

# Cost of random page access relative to sequential access
# Default 4.0 assumes HDD, 1.1 optimized for SSD storage
# Lower value makes random access cheaper, improving query plans for SSDs
random_page_cost = 1.1

# Number of concurrent I/O operations the storage system can handle
# High value (200) appropriate for SSDs with good parallel I/O performance
# Helps optimizer decide on parallel operations
effective_io_concurrency = 200

# =============================================================================
# ERROR REPORTING AND LOGGING
# =============================================================================

# Send logs to stderr (captured by Docker logging)
log_destination = 'stderr'

# Enable log file collection and automatic rotation
logging_collector = on

# Directory for log files (relative to data directory)
log_directory = 'log'

# Log filename pattern with timestamp for easy identification and rotation
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'

# Log queries that take longer than 1000ms (1 second)
# Helps identify performance issues without excessive logging
# Set to lower value (e.g., 500) if you need more detailed performance monitoring
log_min_duration_statement = 1000

# =============================================================================
# AUTOMATIC VACUUM
# =============================================================================
# Critical for applications like Joplin that frequently update/delete records

# Enable automatic vacuum - essential for maintaining database performance
# Prevents table bloat and keeps statistics current
autovacuum = on

# Number of concurrent autovacuum worker processes
# 3 workers good for home servers with moderate activity levels
autovacuum_max_workers = 3

# Time between autovacuum runs (in minutes)
# 1 minute ensures timely cleanup for frequently updated applications
# More aggressive than default to handle Joplin's sync patterns
autovacuum_naptime = 1min

# =============================================================================
# ADDITIONAL NOTES
# =============================================================================
# This configuration is optimized for:
# - Home server environments with shared resources
# - SSD storage (random_page_cost, effective_io_concurrency)
# - Applications like Joplin with frequent small updates
# - Docker/container deployment
# - Moderate concurrent usage (few users/applications)
#
# Adjust memory settings based on your server's total RAM:
# - For 4GB+ RAM: Consider increasing shared_buffers to 512MB-1GB
# - For 8GB+ RAM: Consider increasing effective_cache_size to 2-4GB
# - Monitor actual usage and adjust accordingly