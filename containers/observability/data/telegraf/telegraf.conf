# Telegraf Configuration for Homelab
# Global tags for all metrics
[global_tags]
  environment = "homelab"
  location = "home"

# Agent configuration
[agent]
  interval = "60s"                  # Collection interval (60s balances responsiveness vs N100 resources)
  round_interval = true             # Align collections to interval boundaries
  metric_batch_size = 1000          # Max metrics per batch
  metric_buffer_limit = 10000       # Max metrics in memory before dropping
  collection_jitter = "5s"          # Spread collections over 5s to prevent CPU spikes
  flush_interval = "10s"            # How often to flush to output
  flush_jitter = "0s"               # No randomization of flush timing
  precision = "1s"                  # Timestamp precision (1s is sufficient for homelab, reduces cardinality)
  hostname = "homelab-telegraf"     # Override hostname for consistent identification
  omit_hostname = false             # Include hostname in metrics
  debug = false                     # Production mode (set to true for troubleshooting)

# VictoriaMetrics output
[[outputs.http]]
  url = "http://victoriametrics:8428/api/v1/write"     # VictoriaMetrics Prometheus remote write endpoint
  data_format = "prometheusremotewrite"                # Use Prometheus remote write protocol
  timeout = "10s"                                      # Request timeout
  
  # Optional: Basic authentication (uses Docker Compose environment variables)
  # Leave empty strings if not using authentication
  username = "${VM_AUTH_USERNAME}"                     # Telegraf uses ${VAR} syntax (different from Docker ${VAR:-})
  password = "${VM_AUTH_PASSWORD}"                     # Set in .env file or leave empty
  
  [outputs.http.headers]
    Content-Type = "application/x-protobuf"            # Protobuf format for efficiency
    Content-Encoding = "snappy"                        # Snappy compression (built into Prometheus protocol)
    X-Prometheus-Remote-Write-Version = "0.1.0"        # Protocol version

###########################################
# INPUT PLUGINS
###########################################

# System metrics (CPU, Memory, Disk)
[[inputs.cpu]]
  percpu = true
  totalcpu = true
  collect_cpu_time = false
  report_active = false

[[inputs.disk]]
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]

# Disabled: diskio stats not useful in LXC/Docker containers
# [[inputs.diskio]]
#   skip_serial_number = true

[[inputs.kernel]]

[[inputs.mem]]

[[inputs.processes]]

[[inputs.swap]]

[[inputs.system]]
  fieldexclude = ["uptime_format"]  # Drop formatted uptime (incompatible with Prometheus)

[[inputs.net]]

[[inputs.netstat]]

# Docker metrics
[[inputs.docker]]
  endpoint = "unix:///var/run/docker.sock"             # Docker socket path
  gather_services = false                              # Don't gather swarm services (not using swarm)
  source_tag = false                                   # Don't add source tag
  container_name_include = []                          # Empty = include all
  container_name_exclude = []                          # Empty = exclude none
  timeout = "5s"                                       # Docker API timeout
  perdevice_include = ["cpu", "network", "blkio"]      # Per-container stats for these subsystems
  total_include = ["cpu", "network", "blkio"]          # Fleet-wide aggregate stats
  docker_label_include = [                             # Include useful Docker labels as tags
    "com.docker.compose.service",                      # Docker Compose service name
    "com.docker.compose.project",                      # Docker Compose project name
  ]
  docker_label_exclude = []                            # No exclusions
  tag_env = ["JAVA_HOME", "HEAP_SIZE"]                 # Include these env vars as tags (if present)
  
  # Convert string fields to tags (Prometheus compatibility)
  taginclude = ["container_id", "container_name", "container_image"]
  fieldexclude = ["container_id", "health_status"]     # Don't send string fields as metric values

# SNMP inputs for network devices (DISABLED - requires MIB files)
# To enable: install snmp-mibs-downloader in container and uncomment
# [[inputs.snmp]]
#   agents = ["${ROUTER_IP:192.168.1.1}"]                # Router IP (default: 192.168.1.1, override in .env)
#   version = 2                                          # SNMP version 2c
#   community = "${SNMP_COMMUNITY:public}"               # SNMP community string (default: public, CHANGE THIS!)
#   interval = "60s"                                     # Poll every 60 seconds
#   timeout = "10s"                                      # SNMP request timeout
#   retries = 3                                          # Retry failed requests 3 times
#   
#   # System info
#   [[inputs.snmp.field]]
#     name = "hostname"
#     oid = "SNMPv2-MIB::sysName.0"
#     is_tag = true
#   
#   [[inputs.snmp.field]]
#     name = "uptime"
#     oid = "DISMAN-EVENT-MIB::sysUpTimeInstance"
#   
#   # Interface statistics (using IF-MIB)
#   [[inputs.snmp.table]]
#     name = "interface"
#     inherit_tags = ["hostname"]
#     
#     [[inputs.snmp.table.field]]
#       name = "ifIndex"
#       oid = "IF-MIB::ifIndex"
#       is_tag = true
#     
#     [[inputs.snmp.table.field]]
#       name = "ifDescr"
#       oid = "IF-MIB::ifDescr"
#       is_tag = true
#     
#     [[inputs.snmp.table.field]]
#       name = "ifInOctets"
#       oid = "IF-MIB::ifInOctets"
#     
#     [[inputs.snmp.table.field]]
#       name = "ifOutOctets"
#       oid = "IF-MIB::ifOutOctets"

# UPS monitoring (if you have a UPS with SNMP)
# [[inputs.snmp]]
#   agents = ["192.168.1.100"]  # UPS IP
#   version = 2
#   community = "public"
#   interval = "30s"
#   
#   [[inputs.snmp.field]]
#     name = "battery_status"
#     oid = "1.3.6.1.2.1.33.1.2.1.0"
#   
#   [[inputs.snmp.field]]
#     name = "battery_capacity"
#     oid = "1.3.6.1.2.1.33.1.2.4.0"
#   
#   [[inputs.snmp.field]]
#     name = "input_voltage"
#     oid = "1.3.6.1.2.1.33.1.3.3.1.3.1"
#   
#   [[inputs.snmp.field]]
#     name = "output_voltage"
#     oid = "1.3.6.1.2.1.33.1.4.4.1.2.1"

# Network switch monitoring (adjust IP)
# [[inputs.snmp]]
#   agents = ["192.168.1.2"]  # Switch IP
#   version = 2
#   community = "public"
#   interval = "60s"
#   
#   [[inputs.snmp.field]]
#     name = "hostname"
#     oid = "1.3.6.1.2.1.1.5.0"
#     is_tag = true
#   
#   # Port statistics
#   [[inputs.snmp.table]]
#     name = "switch_port"
#     inherit_tags = ["hostname"]
#     oid = "1.3.6.1.2.1.2.2"
#     
#     [[inputs.snmp.table.field]]
#       name = "port"
#       oid = "1.3.6.1.2.1.2.2.1.1"
#       is_tag = true
#     
#     [[inputs.snmp.table.field]]
#       name = "port_name"
#       oid = "1.3.6.1.2.1.2.2.1.2"
#       is_tag = true
#     
#     [[inputs.snmp.table.field]]
#       name = "admin_status"
#       oid = "1.3.6.1.2.1.2.2.1.7"
#     
#     [[inputs.snmp.table.field]]
#       name = "oper_status"
#       oid = "1.3.6.1.2.1.2.2.1.8"

# Home Assistant metrics (alternative to InfluxDB direct integration)
# [[inputs.http]]
#   urls = ["http://YOUR_HOME_ASSISTANT_IP:8123/api/states"]
#   headers = {"Authorization" = "Bearer YOUR_HA_LONG_LIVED_TOKEN"}
#   data_format = "json"
#   json_query = ".[?(@.entity_id =~ /sensor\\.(temperature|humidity|power)/)]"
#   json_time_key = "last_updated"
#   json_time_format = "2006-01-02T15:04:05.000000+00:00"
#   interval = "30s"

# Ping monitoring for important hosts
[[inputs.ping]]
  urls = [
    "8.8.8.8",                                         # Google DNS (internet connectivity)
    "1.1.1.1",                                         # Cloudflare DNS (alternative internet check)
    # "${ROUTER_IP}"                                   # Gateway - uncomment and set ROUTER_IP in .env
  ]
  count = 3                                            # Send 3 ICMP packets per check
  ping_interval = 1.0                                  # 1 second between pings
  timeout = 3.0                                        # 3 second timeout
  interface = ""                                       # Use default interface

# HTTP response monitoring
[[inputs.http_response]]
  urls = [
    "http://grafana:3000",                             # Grafana UI
    "http://victoriametrics:8428/health",              # VictoriaMetrics health endpoint
    "http://victorialogs:9428/health",                 # VictoriaLogs health endpoint
    "http://searxng:8080"                              # SearXNG search engine
  ]
  response_timeout = "5s"                              # HTTP request timeout
  method = "GET"                                       # Use GET requests
  follow_redirects = false                             # Don't follow redirects (test direct response)
  fieldexclude = ["result_type"]                       # Exclude string result_type (dns_error, etc)
  
  # Add service tags for better identification in metrics
  [inputs.http_response.tags]
    check_type = "http_health"

# Internal temperatures (if available)
# [[inputs.temp]]

# SMART disk monitoring (requires smartmontools in container)
# [[inputs.smart]]
#   use_sudo = false